use crate::{diagnostic, node, pass};

pub struct NameResolutionPass<'a> {
  package_buffer: Option<&'a node::Package>,
}

impl<'a> pass::Pass for NameResolutionPass<'a> {
  // TODO: Generated by Github code-pilot.
  // fn visit_stub(stub: &node::Stub) {
  //   let mut scope = stub.scope();
  //   let mut name = stub.name();
  //   let mut found = false;
  //   while let Some(parent) = scope.parent() {
  //     if let Some(decl) = scope.find_decl(name) {
  //       found = true;
  //       stub.set_decl(decl);
  //       break;
  //     }
  //     scope = parent;
  //   }
  //   if !found {
  //     let mut diag =
  //       diagnostic::Diagnostic::error(&format!("unresolved name `{}`", name), stub.span());
  //     diag.emit();
  //   }
  // }

  fn visit_package(&mut self, package: &node::Package) -> pass::PassResult {
    // FIXME: Address error.
    // self.package_buffer = Some(package);

    Ok(())
  }

  fn visit_stub(&mut self, stub: &mut node::Stub) -> pass::PassResult {
    match stub {
      node::Stub::Callable { name, value } => {
        if value.is_some() {
          return Ok(());
        }

        crate::assert!(self.package_buffer.is_some());

        let package_symbol_table = &self.package_buffer.as_ref().unwrap().symbol_table;

        if !package_symbol_table.contains_key(name) {
          return Err(diagnostic::Diagnostic {
            message: format!("unresolved callee `{}`", name),
            severity: diagnostic::DiagnosticSeverity::Error,
          });
        }
      }
    };

    Ok(())
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::pass::Pass;
}
